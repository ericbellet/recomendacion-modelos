---
title: "Recomendación de artículos"
author: "Eric Bellet"
date: "17 mai 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción
El siguiente sistema de recomendación esta basado en en 131000 transacciones de artículos de un periódico, donde existen 9 artículos por cada contenido, los cuales son:

* Deportes.  
* Politica.
* Variedades. 
* Internacional.
* Nacionales.
* Sucesos.
* Comunidad.
* Negocios.
* Opinión.

# Arules
Se utilizó el paquete arules de R para poder generar reglas de asociación.
```{r, echo=FALSE, results='hide', include=FALSE}

###############CAMBIAR##########################
setwd("C:/Users/Eric/Desktop/recomendacion-modelos/")
################################################

install = function(pkg)
{
  # Si ya está instalado, no lo instala.
  if (!require(pkg, character.only = TRUE)) {
    install.packages(pkg)
    if (!require(pkg, character.only = TRUE)) stop(paste("load failure:", pkg))
  }
}

install('arules')
install('arulesViz')
install('apcluster')
#Cargo las librerias.
library(arules)
library(arulesViz)
library(apcluster)

##-------------------------------LECTURA -----------------------------------

ejemplo <- read.csv("data/ejemplo.csv")
periodico <- read.csv("data/periodico.csv")

```


# Primera parte
Modi???car su dataset de tal manera que no se lean los identi???cadores de los artículos como itemN sino por su tipo de contenido contenido/articuloN. Ejemplo: {item1, item10, item81} es la transacción {deportes/articulo1, politica/articulo1, opinion/articulo9}.

Para modificar el dataset dada estas condiciones se realizó lo siguiente:

* Se cambio el nombre la columna 5 y se creó la columna *articles* y se llenó con vectores númericos que representan los items que observó el usuario.
```{r}
#Cambio el nombre de la columna para que tenga coherencia con el ejemplo dado.
colnames(periodico)[5] <- "items"
#Creo la columna de los articulos
periodico$articles <- periodico$items

#Se sabe que el portal ofrece 9 tipos de contenidos 
#y nos ofrecen solo información de 9 artículos.

#Obtengo el numero de los articulos.
periodico$articles <- strsplit(gsub("[{}item]","",periodico$articles), ",")
```
* Dado los vectores de cada fila de la columna *articles* se modificó para que tuviera el formato *contenido/articuloN* utilizando la función genArticles.
```{r}
genArticles <- function(articles){
  # Genera la columna articles utilizando los items.
  #
  # Args:
  #   articles: Son arreglos númericos que representan los items (EJ: {item1,item9,item63} -> 1,9,63)
  #
  # Returns:
  #   Retorna la columna articles.
  articulo <- ""
  for (i in 1:length(articles)) {
    
    if (as.integer(articles[i]) <= 9 & as.integer(articles[i]) >= 1){
      articulo <- paste(articulo, gsub(" ","",paste("deportes/articulo",articles[i])))
      
    }
    if (as.integer(articles[i]) <= 18 & as.integer(articles[i]) >= 10){
      articulo <- paste(articulo, gsub(" ","",paste("politica/articulo",(as.integer(articles[i])-9))))
      
    }
    if (as.integer(articles[i]) <= 27 & as.integer(articles[i]) >= 19){
      articulo <- paste(articulo, gsub(" ","",paste("variedades/articulo",(as.integer(articles[i])-18))))
      
    }
    if (as.integer(articles[i]) <= 36 & as.integer(articles[i]) >= 28){
      articulo <- paste(articulo, gsub(" ","",paste("internacional/articulo",(as.integer(articles[i])-27))))
      
    }
    if (as.integer(articles[i]) <= 45 & as.integer(articles[i]) >= 37){
      articulo <- paste(articulo, gsub(" ","",paste("nacionales/articulo",(as.integer(articles[i])-36))))
      
    }
    if (as.integer(articles[i]) <= 54 & as.integer(articles[i]) >= 46){
      articulo <- paste(articulo, gsub(" ","",paste("sucesos/articulo",(as.integer(articles[i])-45))))
      
    }
    if (as.integer(articles[i]) <= 63 & as.integer(articles[i]) >= 55){
      articulo <- paste(articulo, gsub(" ","",paste("comunidad/articulo",(as.integer(articles[i])-54))))
      
    }
    if (as.integer(articles[i]) <= 72 & as.integer(articles[i]) >= 64){
      articulo <- paste(articulo, gsub(" ","",paste("negocios/articulo",(as.integer(articles[i])-63))))
      
    }
    if (as.integer(articles[i]) <= 81 & as.integer(articles[i]) >= 73){
      articulo <- paste(articulo, gsub(" ","",paste("opinion/articulo",(as.integer(articles[i])-72))))
      
    }
  }
  return(articulo)
  
}


#Modifico el dataset con las condiciones dadas.
periodico$articles <- lapply(periodico$articles, genArticles)
```
* Finalmente se realizan modificaciones en la columna articles para que tengan el formato adecuado y se calcula el tiempo total que estuvó un usuario observando los artículos.

```{r}
#Convierto los espacios en ,
periodico$articles <- gsub(" ",",",periodico$articles)

#Elimino la primer valor del string.
periodico$articles <- substring(periodico$articles, 2)

#Calculo el tiempo totan el segundos que dura el usuario en la pagina.
periodico$tiempototal <- difftime(periodico$exit, periodico$entry, units =  "secs")


```
Este es el resultado de la primera parte.
```{r}
head(periodico[,c(1,5,6,7)])
```
# Generación de matriz de transacciones
Para poder generar las reglas utilizando el paquete **arules** es necesario tener una matriz de transacciones, para crearla se realizó lo siguiente.

 Se utilizó la función **llenar**, el cual dado lo un vector númerico que representa los items va llenando con 1 aquellos artículos que el usuario observó.
```{r}
#Generar la matriz de transacciones.
#fila es un row inicializado en 0.
fila <- matrix(data = 0, nrow = 1, ncol = 81)
#------------------FUNCTION llenar-----------------
llenar <- function(periodico,fila){
  # Llena la matriz de transacciones con 1 en caso de que el usuario observo los articulos.
  #
  # Args:
  #   periodico: Recibe los items.
  #   fila: recibe una fila vacia.
  #
  # Returns:
  #   Retorna la matriz de transacciones llena.
  items <- as.numeric(unlist(strsplit(gsub("[{}item]","",unlist(periodico)), ",")))
  fila[items]=1
  return(fila)
}

#--------------END FUNCTION llenar-----------------

#Lleno la matriz con 1 donde un usuario observo un articulo
matriz <- lapply(periodico$items, llenar,fila)

```
Transformo el resultado obtenido por la función **llenar** en una matriz y se le asigna el nombre correspondiente a cada columna.
```{r}

#Transformo matriz en una matrix.
matriz <- matrix(unlist(matriz), byrow=T, ncol=81)

#Nombro las columnas
colnames(matriz) <-  c(gsub(" ","",paste("deportes/articulo",1:9)),gsub(" ","",paste("politica/articulo",1:9)),
                       gsub(" ","",paste("variedades/articulo",1:9)), gsub(" ","",paste("internacional/articulo",1:9)),
                       gsub(" ","",paste("nacionales/articulo",1:9)), gsub(" ","",paste("sucesos/articulo",1:9)),
                       gsub(" ","",paste("comunidad/articulo",1:9)), gsub(" ","",paste("negocios/articulo",1:9)),
                       gsub(" ","",paste("opinion/articulo",1:9)))
```
# Detección de usuarios bots
El periódico tiene sospechas de que existen bots que están ganando dinero al hacer clicks en artículos con promociones. En consecuencia, le piden a usted que realice un análisis exploratorio sobre las transacciones para determinar el número de posibles transacciones bot que tienen en su dataset (ellos aceptan que si una persona ve un artículo más de 20 segundos entonces no es un bot). 

Para calcular el número de articulos que observó un usuario se suman las filas de la matriz de transacciones, y luego utilizando el **tiempo total** de un usuario observando los artículos, se calcula cuales son los usuarios **bots** bajo el criterio si una persona ve un artículo 20 segundos o menos entonces es un bot.
```{r}
#El número de posibles transacciones bot que tienen en su dataset 
#(ellos aceptan que si una persona ve un artículo más de 20 segundos entonces no es un bot). 
periodico$numItems <- rowSums(matriz)
numerobots <- periodico[periodico$numItems >= periodico$tiempototal/20,]
print(paste("El numero de transacciones bot es:",nrow(numerobots)))  


periodicoSinBots <- periodico[-numerobots$X,]
#Utilizamos la matriz de transacciones sin las transacciones bots.
matriz <- matriz[-numerobots$X,]
#Matriz de transacciones
mm <- matriz
matriz <- as(matriz, "transactions")
```
Finalmente nos interesa generar las reglas de asociación sin los usuarios bots, por lo tanto se eliminan del dataset y de la matriz de transacciones.

# Segunda parte
Conocer los tipos de usuarios que ingresan a su página (ellos creen que son 8 tipos de usuarios) y tratar de determinar la proporción de cada tipo de usuario.

Si agrupamos utilizando el **lhs** de las reglas, obtenemos estos 8 grupos:
```{r}
rules <- apriori(matriz,parameter = list(support = 0.000008019181883, confidence = 1.0))

plot(rules, method = "grouped", control = list(k = 8))
```

Utilizando **kmedias** usando el algoritmo de **Harting-Wong** se obtiene la siguiente proporción de cada cluster:
```{r}
kmedias <- kmeans(mm, 8,algorithm = "Hartigan-Wong")
periodicoSinBots$cluster <- kmedias$cluster
table(periodicoSinBots$cluster)
```
La propagación por afinidad toma como conjunto de datos principal similitudes entre los datos. El objetivo es minimizar los errores al cuadrado, cada similaridad se establece como el inverso del error cuadrado (distancia euclídea).

Podemos observar que utilizando clusterización mediante la propagación por afinidad detecta 8 clusters donde los tipos de usuarios son los siguientes:
```{r}
#Calculamos la matriz de similaridad utilizando el inverso del error cuadrado (distancia euclidea).
sim <- crossprod(mm)
sim <- sim / sqrt(sim)
#Corremos la affinity propagation
clust_ap <- apcluster(sim) 
show(clust_ap)
```

# Tercera parte
Dado un usuario nuevo que haya ingresado a n artículos (n variable), poder recomendar un artículo n+1 y así aumentar el compromiso del cliente con su portal web. Como usted sabe, para poder calcular las reglas necesita como entrada MinSupport y MinCon???anza. Sin embargo, el cliente desconoce cuáles son estos valores en consecuencia es tarea de usted determinar y justi???car los mismos de acuerdo a su criterio. 

Para recomendar un artículo n + 1 a un usuario se utilizó reglas de asociación. La función implementada es **recomendar** que recibe la matriz de transacciones y el n que representa los artículos ingresados por el usuario. Se generan las reglas con el algoritmo **apriori** con un soporte alto y una confianza baja, en caso de no encontrar un **lhs** en las reglas generadas se va disminuyendo el soporte hasta que se generen reglas, en el caso que no se generen reglas en una cantidad de iteraciones, se recomienda el **rhs** o artículo más popular o que tenga mayor número de apariciones. En el caso que si se generan reglas, se ordenan por confianza de mayor a menor, luego se toman todas las reglas que tengan la misma **confianza máxima** y se ordenan por **soporte** de mayor a menor y finalmente se recomienda el artículo que tenga mayor soporte. En otras palabras se toman las reglas que tengan la confianza máxima y luego la que tenga mayor soporte.

```{r eval=FALSE}
recomendar <- function(n, matriz){
  #plot(rules,method="graph",interactive=TRUE,shading=NA)
  #plot(rules, measure=c("support","lift"), shading="confidence");
  #plot(rules, shading="order", control=list(main ="Two-key plot"));
 

  rules <- apriori(matriz,parameter = list(support = 0.1, confidence = 0.0))
  
  reglas <- subset(rules, subset = lhs %ain% n )

  len <- length(reglas)
  div <- 0.1
  cont <- 0
  #En el caso que no se generaron reglas con ese soporte, voy disminuyendo el soporte
  while (len == 0){
    div <- div /10
    rules <- apriori(matriz,parameter = list(support = div, confidence = 0.0))
    reglas <- subset(rules, subset = lhs %ain% n )
    len <- length(reglas)
    cont <- cont + 1
    #Un criterio de parada ya que puede ser infinito
    if (cont == 7){
      break()
    }
  }
  if (length(reglas)==0){
    trendigtop<-inspect(rules@rhs)
    return(row.names(sort(table(trendigtop),decreasing=TRUE))[1])
  }else{
 
  confianzaAlta <-sort(reglas, decreasing = TRUE, 
                       na.last = NA,by = "confidence",
                       order = FALSE)

  #Obtengo la confianza maxima para luego tomar todos los articulos que posean esa confianza
  maxConfianza <- max(quality((confianzaAlta))[2])
  #Posiciones que poseen la misma confianza.
  confianzaAlta<- subset(confianzaAlta, subset = confidence == maxConfianza)
  
  
  #Ahora ordeno por soporte las que tienen la confianza mas alta
  soportealto <- (sort(confianzaAlta, decreasing = TRUE, 
                                 na.last = NA,by = "support",
                                 order = FALSE)[1])
  articulorecomendar <- inspect(soportealto@rhs[1])
  return(articulorecomendar$items[1])
  }
}

n <- c("deportes/articulo6","internacional/articulo9")
articuloARecomendar <- recomendar(n, matriz)
```

```{r, include=F}
recomendar <- function(n, matriz){
  #plot(rules,method="graph",interactive=TRUE,shading=NA)
  #plot(rules, measure=c("support","lift"), shading="confidence");
  #plot(rules, shading="order", control=list(main ="Two-key plot"));
 

  rules <- apriori(matriz,parameter = list(support = 0.1, confidence = 0.0))
  
  reglas <- subset(rules, subset = lhs %ain% n )

  len <- length(reglas)
  div <- 0.1
  cont <- 0
  #En el caso que no se generaron reglas con ese soporte, voy disminuyendo el soporte
  while (len == 0){
    div <- div /10
    rules <- apriori(matriz,parameter = list(support = div, confidence = 0.0))
    reglas <- subset(rules, subset = lhs %ain% n )
    len <- length(reglas)
    cont <- cont + 1
    #Un criterio de parada ya que puede ser infinito
    if (cont == 7){
      break()
    }
  }
  if (length(reglas)==0){
    trendigtop<-inspect(rules@rhs)
    return(row.names(sort(table(trendigtop),decreasing=TRUE))[1])
  }else{
 
  confianzaAlta <-sort(reglas, decreasing = TRUE, 
                       na.last = NA,by = "confidence",
                       order = FALSE)

  #Obtengo la confianza maxima para luego tomar todos los articulos que posean esa confianza
  maxConfianza <- max(quality((confianzaAlta))[2])
  #Posiciones que poseen la misma confianza.
  confianzaAlta<- subset(confianzaAlta, subset = confidence == maxConfianza)
  
  
  #Ahora ordeno por soporte las que tienen la confianza mas alta
  soportealto <- (sort(confianzaAlta, decreasing = TRUE, 
                                 na.last = NA,by = "support",
                                 order = FALSE)[1])
  articulorecomendar <- inspect(soportealto@rhs[1])
  return(articulorecomendar$items[1])
  }
}

n <- c("deportes/articulo6","internacional/articulo9")
articuloARecomendar <- recomendar(n, matriz)
```
```{r}
print(paste("El artículo que se recomienda es:", articuloARecomendar))
```

# Cuarta parte
Conocer las 10 visitas con mayor tiempo de estadía en la página y las 10 visitas con menor tiempo de estadía en la página.
* Las 10 visitas con mayor tiempo de estadía en la página:
```{r}
timemayor10 <- periodicoSinBots[order(periodicoSinBots$tiempototal,decreasing = T),][1:10,c(1,7)]
print("10 visitas con mayor tiempo de estadía en la página:")
print(timemayor10)
```
* Las 10 visitas con menor tiempo de estadía en la página:
```{r}
timemenor10 <-  periodicoSinBots[order(periodicoSinBots$tiempototal,decreasing = F),][1:10,c(1,7)]
print("10 visitas con menor tiempo de estadía en la página:")
print(timemenor10)
```


# Quinta parte
Conocer las 10 transacciones con mayor número de apariciones en el dataset.

* Los 10 articulos con mayor numero de apariciones.
```{r}
top10 <- sort(itemFrequency(matriz, type = "absolute"),decreasing = T)[1:10]
print("Los 10 articulos con mayor numero de apariciones son:")
print(top10)
itemFrequencyPlot(matriz,topN=10,type="absolute", main ="Los 10 articulos con mayor numero de apariciones.")

```
```{r}
#TRANSACCIONES:
```

* Las 10 transacciones con mayor número de apariciones en el dataset.
```{r}

MatrizSinBots = split(periodicoSinBots$articles,periodicoSinBots$X)
MatrizSinBots = as(MatrizSinBots,"transactions")
top10transacciones <- sort(itemFrequency(MatrizSinBots, type = "absolute"),decreasing = T)[1:10]
print("Las 10 transacciones con mayor numero de apariciones son:")
print(top10transacciones)

itemFrequencyPlot(MatrizSinBots,topN=10,type="absolute", main = "Las 10 transacciones con mayor numero de apariciones.")

```

